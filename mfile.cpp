
#include "mfile.h"

static void find_all_headers(vector<cfile> &files, cfile *file);
static void print_all_headers(FILE *fout, vector<cfile> &files, cfile *file);
static void output_dependencies_helper(FILE *fout, vector<cfile> &files,
                                       cfile *file);

/*==========================================================================*/

mfile::mfile(const string &makefile, vector<cfile> &cfiles, Config &config)
    : m_makefile(makefile), m_cfiles(cfiles), m_cfg(config) {}

int mfile::output() {
    m_fout = fopen(m_makefile.c_str(), "w");
    if (m_fout == NULL) {
        fprintf(stderr, "Can't open file \"%s\", @%s line %d\n",
                m_makefile.c_str(), __func__, __LINE__);
        return EXIT_FAILURE;
    }

    output_header_comments();
    output_build_details_and_compile_to_objects();
    output_build_executable();
    output_dependencies();
    output_clean_up();

    fclose(m_fout);

    return EXIT_SUCCESS;
}

/*==========================================================================*/

void mfile::output_header_comments() {
    fprintf(m_fout, "# Auto generated by ascan, alpha version.\n\n");
}

void mfile::output_build_details_and_compile_to_objects() {
    bool h_c = false, h_cxx = false;
    for (auto it = m_cfiles.begin(); it != m_cfiles.end(); ++it) {
        if (it->file_type() == cfile::C) {
            h_c = true;
            if (h_cxx) {
                break;
            }
        } else if (it->file_type() == cfile::CPP) {
            h_cxx = true;
            if (h_c) {
                break;
            }
        }
    }
    if (!h_c && !h_cxx) {
        h_c = h_cxx = true;
    }

    // Print BUILD DETAILS section

    fprintf(m_fout, "# Build details\n\n");
    if (h_c) {
        fprintf(m_fout, "_CC                     = %s\n", m_cfg.cc.c_str());
    }
    if (h_cxx) {
        fprintf(m_fout, "_CXX                    = %s\n", m_cfg.cxx.c_str());
    }
    if (h_c) {
        fprintf(m_fout, "_CFLAGS                 = %s\n", m_cfg.cflag.c_str());
    }
    if (h_cxx) {
        fprintf(m_fout, "_CXXFLAGS               = %s\n",
                m_cfg.cxxflag.c_str());
    }
    fprintf(m_fout, "\n");

    // Print COMPILE TO OBJECTS section

    fprintf(m_fout, "# Compile to objects\n\n");

    if (h_c) {
        fprintf(m_fout, "%%.o: %%.c\n");
        fprintf(m_fout, "\t$(_CC) $(_CFLAGS) -c -o $@ $<\n");
        fprintf(m_fout, "\n");
    }

    if (h_cxx) {
        fprintf(m_fout, "%%.o: %%.cpp\n");
        fprintf(m_fout, "\t$(_CXX) $(_CXXFLAGS) -c -o $@ $<\n");
        fprintf(m_fout, "\n");
    }
}

static void find_all_headers(vector<cfile> &files, cfile *file) {
    file->set_visited(true);
    for (auto include = file->includes().begin();
         include != file->includes().end(); ++include) {
        if (!(*include)->visited()) {
            find_all_headers(files, *include);
            if ((*include)->associate() &&
                !(*include)->associate()->visited()) {
                find_all_headers(files, (*include)->associate());
            }
        }
    }
}

void mfile::output_build_executable() {
    // find all executable
    for (auto cfile = m_cfiles.begin(); cfile != m_cfiles.end(); ++cfile) {
        if (cfile->have_main_func() && cfile->file_type() != cfile::H) {
            m_executable.push_back(&(*cfile));
        }
    }

    fprintf(m_fout, "# Build Executable\n\n");

    // print all
    fprintf(m_fout, "all:");
    for (auto exec = m_executable.begin(); exec != m_executable.end(); ++exec) {
        fprintf(m_fout, " %s", (*exec)->name().c_str());
    }
    fprintf(m_fout, "\n\n");

    // print executable
    int i = 1;
    for (auto exec = m_executable.begin(); exec != m_executable.end(); ++exec) {
        fprintf(m_fout, "# executable %d\n", i);
        fprintf(m_fout, "_exe%d = %s\n", i, (*exec)->name().c_str());
        fprintf(m_fout, "_objects%d = %s.o", i, (*exec)->name().c_str());

        find_all_headers(m_cfiles, *exec);
        for (auto cfile = m_cfiles.begin(); cfile != m_cfiles.end(); ++cfile) {
            if (cfile->visited()) {
                if (cfile->associate() != NULL &&
                    (cfile->file_type() == cfile::C ||
                     cfile->file_type() == cfile::CPP) &&
                    &(*cfile) != *exec) {
                    fprintf(m_fout, " %s.o",
                            cfile->associate()->name().c_str());
                }
                cfile->set_visited(false);
            }
        }
        fprintf(m_fout, "\n\n");

        fprintf(m_fout, ".PHONY: %s\n", (*exec)->name().c_str());
        fprintf(m_fout, "%s: $(_objects%d)\n", (*exec)->name().c_str(), i);
        if ((*exec)->file_type() == cfile::C) {
            fprintf(m_fout, "\t$(_CC) $(_CFLAGS) -o $(_exe%d) $(_objects%d)\n",
                    i, i);
        } else {
            fprintf(m_fout,
                    "\t$(_CXX) $(_CXXFLAGS) -o $(_exe%d) $(_objects%d)\n", i,
                    i);
        }
        fprintf(m_fout, "\n");

        ++i;
    }
}

static void print_all_headers(FILE *fout, vector<cfile> &files, cfile *file) {
    file->set_visited(true);
    for (auto include = file->includes().begin();
         include != file->includes().end(); ++include) {
        if (!(*include)->visited()) {
            fprintf(fout, " %s.h", (*include)->name().c_str());
            print_all_headers(fout, files, *include);
        }
    }
}

static void output_dependencies_helper(FILE *fout, vector<cfile> &files,
                                       cfile *file) {
    file->set_visited(true);
    if (file->includes().size() > 0) {
        // .c/.cpp depends on all headers it includes, recursively
        fprintf(fout, "%s.o:", file->name().c_str());
        print_all_headers(fout, files, file);
        fprintf(fout, "\n");

        for (auto include = file->includes().begin();
             include != file->includes().end(); ++include) {
            if (!(*include)->visited()) {
                output_dependencies_helper(fout, files, *include);
            }
        }
    } else {
        // .c/.cpp depends on itself if it has no includes
        fprintf(fout, "%s.o: %s%s\n", file->name().c_str(),
                file->name().c_str(), file->ext());
    }
}

void mfile::output_dependencies() {
    fprintf(m_fout, "# Dependencies\n\n");
    for (auto cfile = m_cfiles.begin(); cfile != m_cfiles.end(); ++cfile) {
        if (cfile->file_type() != cfile::H) {
            output_dependencies_helper(m_fout, m_cfiles, &(*cfile));
        }
        for (auto cfile2 = m_cfiles.begin(); cfile2 != m_cfiles.end();
             ++cfile2) {
            if (cfile2->file_type() == cfile::H) {
                cfile2->set_visited(false);
            }
        }
    }
    fprintf(m_fout, "\n");
}

void mfile::output_clean_up() {
    fprintf(m_fout, "# Clean up\n\n");
    fprintf(m_fout, ".PHONY: clean\n");
    fprintf(m_fout, "clean:\n");
    fprintf(m_fout, "\trm -f");

    for (unsigned int i = 0; i < m_executable.size(); ++i) {
        fprintf(m_fout, " \"$(_exe%u)\" $(_objects%u)", i + 1, i + 1);
    }
    fprintf(m_fout, "\n");
}

/*==========================================================================*/