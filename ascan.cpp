#include <string.h>
#include <iostream>

#include "ascan.h"

static void output_header_comments(FILE *fout);
static void output_build_details_and_compile_to_objects(FILE *fout,
                                                        vector<cfiles> &files,
                                                        Config &cfg);
static vector<cfiles *> output_build_executable(FILE *fout,
                                                vector<cfiles> &files);
static void output_dependencies(FILE *fout, vector<cfiles> &files,
                                const vector<cfiles *> &executables);
static void output_clean_up(FILE *fout, const vector<cfiles *> &executables);

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

// void output_config(const string &config, Config &cfg) {}

void output_makefile(const string &makefile, vector<cfiles> &files,
                     Config &cfg) {
    FILE *fout = fopen(makefile.c_str(), "w");
    if (fout == NULL) {
        fprintf(stderr, "Can't open file \"%s\", @%s line %d\n",
                makefile.c_str(), __func__, __LINE__);
        exit(EXIT_FAILURE);
    }

    output_header_comments(fout);

    output_build_details_and_compile_to_objects(fout, files, cfg);

    vector<cfiles *> executables = output_build_executable(fout, files);

    output_dependencies(fout, files, executables);

    output_clean_up(fout, executables);

    fclose(fout);
}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

static void output_header_comments(FILE *fout) {
    fprintf(fout, "# Auto generated by ascan, alpha version.\n\n");
}

static void output_build_details_and_compile_to_objects(FILE *fout,
                                                        vector<cfiles> &files,
                                                        Config &cfg) {
    bool h_c = false, h_cxx = false;
    for (auto it = files.begin(); it != files.end(); ++it) {
        if (it->file_type() == cfiles::C) {
            h_c = true;
            if (h_cxx) {
                break;
            }
        } else if (it->file_type() == cfiles::CPP) {
            h_cxx = true;
            if (h_c) {
                break;
            }
        }
    }
    if (!h_c && !h_cxx) {
        h_c = h_cxx = true;
    }

    // Print BUILD DETAILS section

    fprintf(fout, "# Build details\n\n");
    if (h_c) {
        fprintf(fout, "_CC                     = %s\n", cfg.cc.c_str());
    }
    if (h_cxx) {
        fprintf(fout, "_CXX                    = %s\n", cfg.cxx.c_str());
    }
    if (h_c) {
        fprintf(fout, "_CFLAGS                 = %s\n", cfg.cflag.c_str());
    }
    if (h_cxx) {
        fprintf(fout, "_CXXFLAGS               = %s\n", cfg.cxxflag.c_str());
    }
    fprintf(fout, "\n");

    // Print COMPILE TO OBJECTS section

    fprintf(fout, "# Compile to objects\n\n");

    if (h_c) {
        fprintf(fout, "%%.o: %%.c\n");
        fprintf(fout, "\t$(_CC) $(_CFLAGS) -c -o $@ $<\n");
        fprintf(fout, "\n");
    }

    if (h_cxx) {
        fprintf(fout, "%%.o: %%.cpp\n");
        fprintf(fout, "\t$(_CXX) $(_CXXFLAGS) -c -o $@ $<\n");
        fprintf(fout, "\n");
    }
}

void find_all_headers(vector<cfiles> &files, cfiles *file) {
    file->set_visited(true);
    for (auto include = file->includes().begin();
         include != file->includes().end(); ++include) {
        if (!(*include)->visited()) {
            find_all_headers(files, *include);
            if ((*include)->associate() != NULL) {
                find_all_headers(files, (*include)->associate());
            }
        }
    }
}

static vector<cfiles *> output_build_executable(FILE *fout,
                                                vector<cfiles> &files) {
    // Print BUILD EXECUTABLE section

    fprintf(fout, "# Build Executable\n\n");
    vector<cfiles *> executables;
    for (auto file1 = files.begin(); file1 != files.end(); ++file1) {
        if (file1->have_main_func()) {
            executables.push_back(&(*file1));
        }
    }

    fprintf(fout, "all:");
    for (auto exec = executables.begin(); exec != executables.end(); ++exec) {
        fprintf(fout, " %s", (*exec)->name().c_str());
    }
    fprintf(fout, "\n\n");

    int i = 1;
    for (auto exec = executables.begin(); exec != executables.end(); ++exec) {
        fprintf(fout, "# executable %d\n", i);
        fprintf(fout, "_exe%d = %s\n", i, (*exec)->name().c_str());
        fprintf(fout, "_objects%d = %s.o", i, (*exec)->name().c_str());

        find_all_headers(files, *exec);
        for (auto file2 = files.begin(); file2 != files.end(); ++file2) {
            if (file2->visited()) {
                if (file2->associate() != NULL &&
                    (file2->file_type() == cfiles::C ||
                     file2->file_type() == cfiles::CPP)) {
                    fprintf(fout, " %s.o", file2->associate()->name().c_str());
                }
                file2->set_visited(false);
            }
        }
        fprintf(fout, "\n\n");

        fprintf(fout, ".PHONY: %s\n", (*exec)->name().c_str());
        fprintf(fout, "%s: $(_objects%d)\n", (*exec)->name().c_str(), i);
        if ((*exec)->file_type() == cfiles::C) {
            fprintf(fout, "\t$(_CC) $(_CFLAGS) -o $(_exe%d) $(_objects%d)\n", i,
                    i);
        } else {
            fprintf(fout, "\t$(_CXX) $(_CXXFLAGS) -o $(_exe%d) $(_objects%d)\n",
                    i, i);
        }
        fprintf(fout, "\n");

        ++i;
    }
    return executables;
}

void print_all_headers(FILE *fout, vector<cfiles> &files, cfiles *file) {
    file->set_visited(true);
    for (auto include = file->includes().begin();
         include != file->includes().end(); ++include) {
        if (!(*include)->visited()) {
            fprintf(fout, " %s.h", (*include)->name().c_str());
            print_all_headers(fout, files, *include);
        }
    }
}

void output_dependencies_helper(FILE *fout, vector<cfiles> &files,
                                cfiles *file) {
    file->set_visited(true);
    if (file->includes().size() > 0) {
        fprintf(fout, "%s.o:", file->name().c_str());
        print_all_headers(fout, files, file);
        fprintf(fout, "\n");

        for (auto include = file->includes().begin();
             include != file->includes().end(); ++include) {
            if (!(*include)->visited()) {
                output_dependencies_helper(fout, files, *include);
            }
        }
    } else {
        fprintf(fout, "%s.o: %s%s\n", file->name().c_str(),
                file->name().c_str(), file->ext());
    }
}

static void output_dependencies(FILE *fout, vector<cfiles> &files,
                                const vector<cfiles *> &executables) {
    // Print DEPENDENCIES section

    (void)executables;

    fprintf(fout, "# Dependencies\n\n");
    // for (auto exec = executables.begin(); exec != executables.end(); ++exec)
    // {
    //     output_dependencies_helper(fout, files, *exec);
    //     for (auto cfile = files.begin(); cfile != files.end(); ++cfile) {
    //         if (strcmp(cfile->ext(), ".h") == 0) {
    //             cfile->set_visited(false);
    //         }
    //     }
    // }
    for (auto cfile = files.begin(); cfile != files.end(); ++cfile) {
        if (cfile->file_type() != cfiles::H) {
            output_dependencies_helper(fout, files, &(*cfile));
        }
        for (auto cfile2 = files.begin(); cfile2 != files.end(); ++cfile2) {
            if (cfile2->file_type() == cfiles::H) {
                cfile2->set_visited(false);
            }
        }
    }
    fprintf(fout, "\n");
}

static void output_clean_up(FILE *fout, const vector<cfiles *> &executables) {
    // Print CLEAN UP section

    fprintf(fout, "# Clean up\n\n");
    fprintf(fout, ".PHONY: clean\n");
    fprintf(fout, "clean:\n");
    fprintf(fout, "\trm -f");

    for (unsigned int i = 0; i < executables.size(); ++i) {
        fprintf(fout, " \"$(_exe%u)\" $(_objects%u)", i + 1, i + 1);
    }
    fprintf(fout, "\n");
}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
